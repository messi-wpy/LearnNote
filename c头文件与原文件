写c或c++，刚开始写的很小的程序不需要多个c文件什么的，所以也不需要什么头文件
但最近学习真的被烦死了，.h和.c真不知道是什么关系，有时编译器又出现重复定义什
么的，所以今天专门去看了一下，恍然大悟...

1.<>带便从系统INCLUDE环境变量中指定的地址寻找文件，""首先从当前文件中寻找　　

好进入正题
1. 复习一下　编译器工作过程：

  1. 预处理阶段 ，包括把include文件"复制进来"
  2. 词法与语法分析阶段
  3. 编译阶段，首先编译成纯汇编语句，再将之汇编成跟CPU相关的二进制码，生成各个目标文件 (.obj文件)
  4. 连接阶段，将各个目标文件中的各段代码进行绝对地址定位，生成跟特定平台相关的可执行文件，当然，最后还可以用objcopy生成纯二进制码，也就是去掉了文件格式信息。（生成.exe文件）

    　
2. 首先认识include,他就相当于把include的文件完全ctrl+a复制进来，
更直接一点，很多编译器并不care到底这个文件的后缀名是什么（哪怕是txt）----因为#include预处理就是完成了一个“复制并插入代码”的工作。
3. 重点看编译时和链接时，
  - 编译时
 编译的时候，以.c文件为单位，先把并不会去找b.cpp文件中的函数实现，只有在link的时候才进行这个工作,因为头文件的函数声明，已经可以满足编译，比如函数名字，参数返回值，等等信息都已经有了，
 只需要把它写好，在链接时再去定位找具体实现就可以了，下面有更为具体的描述
 > 在预处理阶段,预处理器看到#include "文件名"就把这个文件读进来,比如它编译main.cpp，看到#include   "a.h"，它就把a.h的内容读进来，它知道了，有一类A，包含一个成员函数f，这个函数接受一个int型的参数，返回一个int型的值。再往下编译很容易就把A   a这行读懂了，它知道是要拿A这个类在栈上生成一个对象。再往下，它知道了下面要调用A的成员函数f了，参数是3，由于它知道这个函数要一个整形数用参数，这个3正好匹配，那就正好把它放到栈上，生成一条调用f(int)函数的指令（一般可能是一句call），至于这个f(int)函数到底在哪里，它不知道，它留着空，链接时再解决。它还知道f(int)函数要返回一个int，所以也许它也为这一点做好了准备（在例子中，我们没用这个返回值，也许它就不处理）。再往下到文件末尾了main.cpp编译好了，生成了main.obj。整个编译过程中根本就不需要知道a.cpp的内容。
同理，编译器再编译a.cpp，把f()函数编译好，编译a.cpp时，它也不用管别的，把f()编译好就行了。生成了a.obj。
最后一步就是链接的阶段了，链接器把项目中所有.cpp生成的所有.obj链接起来，
在这一步中，它就明确了f(int)函数的实现所在的地址，把main.obj中空着的这个地址位置填上正确的地址。最终生成了可执行文件main.exe。


  　 - 链接
    把指定的编译的.c文件链接起来，主要是函数定义实现的地址定位，可以指定需要连接的文件，

    在link的时候，需要在makefile里面说明需要连接哪个.o或.obj文件（在这里是b.cpp生成的.o或.obj文件），此时，连接器会去这个.o或.obj文件中找在b.cpp中实现的函数，再把他们build到makefile中指定的那个可以执行文件中。
在VC中，一帮情况下不需要自己写makefile，只需要将需要的文件都包括在project中，VC会自动帮你把makefile写好。
    比如clion里的，使用cmake,可以编写makefile文件，就可以在里面指定需要编译的文件
    一般的ide，可能默认吧同项目中的.c文件链接起来



4.所以明白上述后，就可以清楚二者的关系了。所以理论上说，头文件和原文件不一定要同名，二者没有必要的联系，只要编译时能正常通过，连接时能找到
函数的实现位置就可以.  




那么问题来了，为什么java同一包内不需要引入头文件呢？
